
public final class GreelinexMap<K, V> {

    Node root;
    int size;

    public static final int GROW_SIZE = 256;
    final static int mSize = GROW_SIZE;
    final static int mSizeMinus1 = mSize - 1;
    final static int mSizeBy2 = GROW_SIZE / 2;
    final static int mSizeBy2Minus1 = mSizeBy2 - 1;
    final static int mSizeBy4 = GROW_SIZE / 4;
    final static int mSizeBy4Minus1 = mSizeBy4 - 1;

    public GreelinexMap() {
        root = new Node();
        root.filledUpto = -1;
        root.isLeaf = true;
        root.data = new Comparable[GROW_SIZE];
        size = 0;
    }

    private int binarySearch(Object key, Node node) {
        int first, last, middle;
        first = 0;
        last = node.filledUpto;
        middle = first + (last - first) / 2;
        while (first <= last) {
            int cmp;
            if (node.isLeaf)
                cmp = ((Comparable) key).compareTo(node.data[middle]);
            else {
                Node child = (Node) node.children[middle];
                Node nextChild = null;
                if (node.filledUpto > middle)
                    nextChild = (Node) node.children[middle + 1];
                if (child.first.compareTo(key) > 0)
                    cmp = -1;
                else if (nextChild != null && nextChild.first.compareTo(key) <= 0)
                    cmp = 1;
                else
                    cmp = 0;
            }
            if (cmp == 0)
                return middle;
            else if (cmp > 0)
                first = middle + 1;
            else if (cmp < 0)
                last = middle - 1;
            middle = first + (last - first) / 2;
        }
        return ~middle;
    }

    public Node recursiveSearch(K key, Node node) {
        Node currentNode = node;
        while (currentNode.filledUpto != -1) {
            currentNode.lastSearchPos = binarySearch(key, currentNode);
            if (!currentNode.isLeaf) {
                if (currentNode.lastSearchPos < 0)
                    currentNode.lastSearchPos = ~currentNode.lastSearchPos;
                if (currentNode.lastSearchPos > currentNode.filledUpto)
                    currentNode.lastSearchPos = currentNode.filledUpto;
            }
            if (currentNode.isLeaf)
                break;
            else
                currentNode = (Node) currentNode.children[currentNode.lastSearchPos];
        }
        return currentNode;
    }

    public V get(K key) {
        if (root.filledUpto == -1)
            return null;
        Node foundNode = recursiveSearch(key, root);
        if (foundNode.lastSearchPos < 0 || !foundNode.isLeaf)
            return null;
        return (V) foundNode.data[mSizeBy2 + foundNode.lastSearchPos];
    }

    private V recursiveUpdate(Node node, Object key, V value) {
        V returnValue = null;
        int idx = node.lastSearchPos;
        Object[] arr = (node.isLeaf ? node.data : node.children);
        if (idx < 0) {
            idx = ~idx;
            if (node.filledUpto == mSizeBy2Minus1) {
                Node newNode = new Node();
                Object[] newArray;
                if (node.isLeaf) {
                    newNode.data = new Comparable[mSize];
                    newNode.first = (Comparable) arr[mSizeBy4];
                    newArray = newNode.data;
                } else {
                    newNode.children = new Object[mSizeBy2];
                    newNode.first = (Comparable) ((Node) arr[mSizeBy4]).first;
                    newNode.isLeaf = false;
                    newArray = newNode.children;
                }
                newNode.parent = node.parent;
                System.arraycopy(arr, mSizeBy4, newArray, 0, mSizeBy4);
                if (node.isLeaf)
                    System.arraycopy(arr, mSizeBy2 + mSizeBy4, newArray, mSizeBy2, mSizeBy4);
                else {
                    for (int i = 0; i < mSizeBy4; i++) {
                        Node child = (Node) newArray[i];
                        child.parent = newNode;
                    }
                }
                newNode.filledUpto = node.filledUpto = mSizeBy4Minus1;
                if (node.parent == null) {
                    node.parent = new Node();
                    root = node.parent;
                    root.first = node.first;
                    root.children = new Object[mSizeBy2];
                    root.children[0] = node;
                    root.children[1] = newNode;
                    root.isLeaf = false;
                    root.filledUpto = 1;
                    root.lastSearchPos = 0;
                    newNode.parent = root;
                } else {
                    if (node.parent.lastSearchPos == node.parent.filledUpto)
                        node.parent.lastSearchPos = ~(node.parent.filledUpto + 1);
                    else
                        node.parent.lastSearchPos = ~(node.parent.lastSearchPos + 1);
                    recursiveUpdate(node.parent, newNode, null);
                }
                // System.out.println("Grow");
                if (idx > mSizeBy4Minus1) {
                    node = newNode;
                    arr = (node.isLeaf ? newNode.data : newNode.children);
                    idx -= mSizeBy4;
                    if (!node.isLeaf)
                        ((Node) key).parent = newNode;
                }
            }
            if (idx <= node.filledUpto)
                System.arraycopy(arr, idx, arr, idx + 1, node.filledUpto - idx + 1);
            arr[idx] = key;
            if (node.isLeaf) {
                if (idx <= node.filledUpto)
                    System.arraycopy(arr, idx + mSizeBy2, arr, idx + 1 + mSizeBy2, node.filledUpto - idx + 1);
                arr[idx + mSizeBy2] = value;
                size++;
            }
            if (idx == 0) {
                if (node.isLeaf)
                    node.first = (Comparable) arr[0];
                else
                    node.first = (Comparable) ((Node) arr[0]).first;
                updateParentsRecursively(node, node.first);
            }
            node.filledUpto++;
        } else {
            if (node.isLeaf) {
                int vIdx = idx + mSizeBy2;
                returnValue = (V) arr[vIdx];
                arr[vIdx] = value;
            }
        }
        return returnValue;
    }

    private void updateParentsRecursively(Node node, Comparable first) {
        if (node == null)
            return;
        Node parent = node.parent;
        if (parent != null && parent.children[0].equals(node)) {
            parent.first = first;
            updateParentsRecursively(parent, first);
        }
    }

    public V put(K key, V value) {
        if (root.filledUpto == -1) {
            root.data[0] = root.first = (Comparable) key;
            root.data[mSizeBy2] = (Comparable) value;
            root.filledUpto++;
            size++;
            return null;
        }
        V returnValue = value;
        Node foundNode = recursiveSearch(key, root);
        returnValue = recursiveUpdate(foundNode, key, value);
        return value;
    }

    public int size() {
        return size;
    }

    class Node {
        public Node() {
        }

        Comparable first = null;
        Comparable[] data = null;
        Node parent = null;
        Object[] children = null;
        boolean isLeaf = true;
        int filledUpto = -1;
        int lastSearchPos = -1;
    }

}
